# k8.yml
name: Kubernetes Deployment

on:
  workflow_run:
    workflows: ["Build and Deploy"]  # This refers to the workflow name in main.yml
    types:
      - completed
    branches:
      - master

permissions:
  id-token: write
  contents: read

jobs:
  deploy-to-k8s:
    # Only run if the Build and Deploy workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        aws-region: us-east-1
        role-session-name: GitHubActions-${{ github.run_id }}

    - name: Get workflow outputs
      run: |
        # Get the outputs from the previous workflow
        CLUSTER_NAME=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}" \
          | jq -r '.outputs.cluster_name')
        ECR_URL=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}" \
          | jq -r '.outputs.ecr_repository_url')
        echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
        echo "ECR_REGISTRY=$ECR_URL" >> $GITHUB_ENV

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region us-east-1

    - name: Deploy to Kubernetes
      env:
        ECR_REGISTRY: ${{ needs.deploy-infrastructure.outputs.ecr_repository_url }}
        IMAGE_TAG: ${{ github.sha }}
        CLUSTER_NAME: eagle-eks-cluster
        REPO_NAME: falcon_ecr  # Add this to match your deployment.yml
      run: |
            cd aws_infra
            
            echo "Verifying EKS cluster..."
            aws eks describe-cluster --name $CLUSTER_NAME || exit 1
            
            echo "Setting up node group..."
            # Get VPC info
            VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME --query 'cluster.resourcesVpcConfig.vpcId' --output text)
            SUBNET_IDS=$(aws eks describe-cluster --name $CLUSTER_NAME --query 'cluster.resourcesVpcConfig.subnetIds[]' --output text)
            
            # Get or create IAM role for nodes
            NODE_ROLE_NAME="${CLUSTER_NAME}-node-role"
            NODE_ROLE_ARN=$(aws iam get-role --role-name $NODE_ROLE_NAME --query 'Role.Arn' --output text)
            
            echo "Using Node Role ARN: $NODE_ROLE_ARN"
            echo "Using Subnet IDs: $SUBNET_IDS"
            
            # Check for existing node groups
            NODE_GROUPS=$(aws eks list-nodegroups --cluster-name $CLUSTER_NAME --query 'nodegroups[*]' --output text || echo "")
            
            if [ -z "$NODE_GROUPS" ]; then
            echo "Creating node group with role $NODE_ROLE_ARN"
            aws eks create-nodegroup \
                --cluster-name $CLUSTER_NAME \
                --nodegroup-name managed-ng \
                --subnets $SUBNET_IDS \
                --instance-types t3.xlarge \  # Changed to t3.xlarge for higher CPU capacity
                --node-role $NODE_ROLE_ARN \
                --scaling-config minSize=1,maxSize=3,desiredSize=2 \
                --disk-size 20 \
                --ami-type AL2_x86_64
            
            echo "Waiting for node group to become active..."
            aws eks wait nodegroup-active \
                --cluster-name $CLUSTER_NAME \
                --nodegroup-name managed-ng
            fi
            
            echo "Waiting for nodes to join cluster..."
            until kubectl get nodes | grep -q "Ready"; do
            echo "Waiting for nodes..."
            sleep 10
            done
            
            echo "Applying deployment..."
            # Use your existing deployment.yml with envsubst
            envsubst < k8s/deployment.yml | kubectl apply -f -
            kubectl apply -f k8s/service.yml
            kubectl apply -f k8s/ingress.yml
            
            echo "Waiting for deployment rollout..."
            kubectl rollout status deployment/massage-website --timeout=300s
        
            echo "Checking pod status..."
            kubectl get pods -l app=massage-website
            kubectl describe pods -l app=massage-website